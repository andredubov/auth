// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/andredubov/auth/internal/repository.Users -o users_minimock.go -n UsersMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/andredubov/auth/internal/service/model"
	"github.com/gojuno/minimock/v3"
)

// UsersMock implements repository.Users
type UsersMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, user model.User) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, user model.User)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mUsersMockCreate

	funcDelete          func(ctx context.Context, userID int64) (i1 int64, err error)
	inspectFuncDelete   func(ctx context.Context, userID int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUsersMockDelete

	funcGetByID          func(ctx context.Context, userID int64) (up1 *model.User, err error)
	inspectFuncGetByID   func(ctx context.Context, userID int64)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mUsersMockGetByID

	funcUpdate          func(ctx context.Context, updateUserInfo model.UpdateUserInfo) (i1 int64, err error)
	inspectFuncUpdate   func(ctx context.Context, updateUserInfo model.UpdateUserInfo)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mUsersMockUpdate
}

// NewUsersMock returns a mock for repository.Users
func NewUsersMock(t minimock.Tester) *UsersMock {
	m := &UsersMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mUsersMockCreate{mock: m}
	m.CreateMock.callArgs = []*UsersMockCreateParams{}

	m.DeleteMock = mUsersMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UsersMockDeleteParams{}

	m.GetByIDMock = mUsersMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*UsersMockGetByIDParams{}

	m.UpdateMock = mUsersMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*UsersMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUsersMockCreate struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockCreateExpectation
	expectations       []*UsersMockCreateExpectation

	callArgs []*UsersMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockCreateExpectation specifies expectation struct of the Users.Create
type UsersMockCreateExpectation struct {
	mock      *UsersMock
	params    *UsersMockCreateParams
	paramPtrs *UsersMockCreateParamPtrs
	results   *UsersMockCreateResults
	Counter   uint64
}

// UsersMockCreateParams contains parameters of the Users.Create
type UsersMockCreateParams struct {
	ctx  context.Context
	user model.User
}

// UsersMockCreateParamPtrs contains pointers to parameters of the Users.Create
type UsersMockCreateParamPtrs struct {
	ctx  *context.Context
	user *model.User
}

// UsersMockCreateResults contains results of the Users.Create
type UsersMockCreateResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mUsersMockCreate) Optional() *mUsersMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for Users.Create
func (mmCreate *mUsersMockCreate) Expect(ctx context.Context, user model.User) *mUsersMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UsersMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UsersMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("UsersMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &UsersMockCreateParams{ctx, user}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for Users.Create
func (mmCreate *mUsersMockCreate) ExpectCtxParam1(ctx context.Context) *mUsersMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UsersMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UsersMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UsersMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UsersMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreate
}

// ExpectUserParam2 sets up expected param user for Users.Create
func (mmCreate *mUsersMockCreate) ExpectUserParam2(user model.User) *mUsersMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UsersMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UsersMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UsersMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UsersMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.user = &user

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Users.Create
func (mmCreate *mUsersMockCreate) Inspect(f func(ctx context.Context, user model.User)) *mUsersMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for UsersMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Users.Create
func (mmCreate *mUsersMockCreate) Return(i1 int64, err error) *UsersMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UsersMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UsersMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &UsersMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the Users.Create method
func (mmCreate *mUsersMockCreate) Set(f func(ctx context.Context, user model.User) (i1 int64, err error)) *UsersMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Users.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Users.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the Users.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mUsersMockCreate) When(ctx context.Context, user model.User) *UsersMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UsersMock.Create mock is already set by Set")
	}

	expectation := &UsersMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &UsersMockCreateParams{ctx, user},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Users.Create return parameters for the expectation previously defined by the When method
func (e *UsersMockCreateExpectation) Then(i1 int64, err error) *UsersMock {
	e.results = &UsersMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times Users.Create should be invoked
func (mmCreate *mUsersMockCreate) Times(n uint64) *mUsersMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of UsersMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	return mmCreate
}

func (mmCreate *mUsersMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements repository.Users
func (mmCreate *UsersMock) Create(ctx context.Context, user model.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, user)
	}

	mm_params := UsersMockCreateParams{ctx, user}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := UsersMockCreateParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("UsersMock.Create got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreate.t.Errorf("UsersMock.Create got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("UsersMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the UsersMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, user)
	}
	mmCreate.t.Fatalf("Unexpected call to UsersMock.Create. %v %v", ctx, user)
	return
}

// CreateAfterCounter returns a count of finished UsersMock.Create invocations
func (mmCreate *UsersMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of UsersMock.Create invocations
func (mmCreate *UsersMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mUsersMockCreate) Calls() []*UsersMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*UsersMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *UsersMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.Create with params: %#v", *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.Create")
		} else {
			m.t.Errorf("Expected call to UsersMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Error("Expected call to UsersMock.Create")
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.Create but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), afterCreateCounter)
	}
}

type mUsersMockDelete struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockDeleteExpectation
	expectations       []*UsersMockDeleteExpectation

	callArgs []*UsersMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockDeleteExpectation specifies expectation struct of the Users.Delete
type UsersMockDeleteExpectation struct {
	mock      *UsersMock
	params    *UsersMockDeleteParams
	paramPtrs *UsersMockDeleteParamPtrs
	results   *UsersMockDeleteResults
	Counter   uint64
}

// UsersMockDeleteParams contains parameters of the Users.Delete
type UsersMockDeleteParams struct {
	ctx    context.Context
	userID int64
}

// UsersMockDeleteParamPtrs contains pointers to parameters of the Users.Delete
type UsersMockDeleteParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// UsersMockDeleteResults contains results of the Users.Delete
type UsersMockDeleteResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mUsersMockDelete) Optional() *mUsersMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for Users.Delete
func (mmDelete *mUsersMockDelete) Expect(ctx context.Context, userID int64) *mUsersMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UsersMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UsersMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("UsersMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &UsersMockDeleteParams{ctx, userID}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for Users.Delete
func (mmDelete *mUsersMockDelete) ExpectCtxParam1(ctx context.Context) *mUsersMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UsersMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UsersMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UsersMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UsersMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelete
}

// ExpectUserIDParam2 sets up expected param userID for Users.Delete
func (mmDelete *mUsersMockDelete) ExpectUserIDParam2(userID int64) *mUsersMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UsersMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UsersMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UsersMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UsersMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.userID = &userID

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Users.Delete
func (mmDelete *mUsersMockDelete) Inspect(f func(ctx context.Context, userID int64)) *mUsersMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UsersMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Users.Delete
func (mmDelete *mUsersMockDelete) Return(i1 int64, err error) *UsersMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UsersMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UsersMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UsersMockDeleteResults{i1, err}
	return mmDelete.mock
}

// Set uses given function f to mock the Users.Delete method
func (mmDelete *mUsersMockDelete) Set(f func(ctx context.Context, userID int64) (i1 int64, err error)) *UsersMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Users.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Users.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the Users.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUsersMockDelete) When(ctx context.Context, userID int64) *UsersMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UsersMock.Delete mock is already set by Set")
	}

	expectation := &UsersMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &UsersMockDeleteParams{ctx, userID},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Users.Delete return parameters for the expectation previously defined by the When method
func (e *UsersMockDeleteExpectation) Then(i1 int64, err error) *UsersMock {
	e.results = &UsersMockDeleteResults{i1, err}
	return e.mock
}

// Times sets number of times Users.Delete should be invoked
func (mmDelete *mUsersMockDelete) Times(n uint64) *mUsersMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of UsersMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	return mmDelete
}

func (mmDelete *mUsersMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements repository.Users
func (mmDelete *UsersMock) Delete(ctx context.Context, userID int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, userID)
	}

	mm_params := UsersMockDeleteParams{ctx, userID}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := UsersMockDeleteParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("UsersMock.Delete got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDelete.t.Errorf("UsersMock.Delete got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UsersMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UsersMock.Delete")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, userID)
	}
	mmDelete.t.Fatalf("Unexpected call to UsersMock.Delete. %v %v", ctx, userID)
	return
}

// DeleteAfterCounter returns a count of finished UsersMock.Delete invocations
func (mmDelete *UsersMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UsersMock.Delete invocations
func (mmDelete *UsersMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUsersMockDelete) Calls() []*UsersMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UsersMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UsersMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.Delete with params: %#v", *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.Delete")
		} else {
			m.t.Errorf("Expected call to UsersMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Error("Expected call to UsersMock.Delete")
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.Delete but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), afterDeleteCounter)
	}
}

type mUsersMockGetByID struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockGetByIDExpectation
	expectations       []*UsersMockGetByIDExpectation

	callArgs []*UsersMockGetByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockGetByIDExpectation specifies expectation struct of the Users.GetByID
type UsersMockGetByIDExpectation struct {
	mock      *UsersMock
	params    *UsersMockGetByIDParams
	paramPtrs *UsersMockGetByIDParamPtrs
	results   *UsersMockGetByIDResults
	Counter   uint64
}

// UsersMockGetByIDParams contains parameters of the Users.GetByID
type UsersMockGetByIDParams struct {
	ctx    context.Context
	userID int64
}

// UsersMockGetByIDParamPtrs contains pointers to parameters of the Users.GetByID
type UsersMockGetByIDParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// UsersMockGetByIDResults contains results of the Users.GetByID
type UsersMockGetByIDResults struct {
	up1 *model.User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByID *mUsersMockGetByID) Optional() *mUsersMockGetByID {
	mmGetByID.optional = true
	return mmGetByID
}

// Expect sets up expected params for Users.GetByID
func (mmGetByID *mUsersMockGetByID) Expect(ctx context.Context, userID int64) *mUsersMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("UsersMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &UsersMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.paramPtrs != nil {
		mmGetByID.mock.t.Fatalf("UsersMock.GetByID mock is already set by ExpectParams functions")
	}

	mmGetByID.defaultExpectation.params = &UsersMockGetByIDParams{ctx, userID}
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// ExpectCtxParam1 sets up expected param ctx for Users.GetByID
func (mmGetByID *mUsersMockGetByID) ExpectCtxParam1(ctx context.Context) *mUsersMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("UsersMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &UsersMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("UsersMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &UsersMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetByID
}

// ExpectUserIDParam2 sets up expected param userID for Users.GetByID
func (mmGetByID *mUsersMockGetByID) ExpectUserIDParam2(userID int64) *mUsersMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("UsersMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &UsersMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("UsersMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &UsersMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.userID = &userID

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the Users.GetByID
func (mmGetByID *mUsersMockGetByID) Inspect(f func(ctx context.Context, userID int64)) *mUsersMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for UsersMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by Users.GetByID
func (mmGetByID *mUsersMockGetByID) Return(up1 *model.User, err error) *UsersMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("UsersMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &UsersMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &UsersMockGetByIDResults{up1, err}
	return mmGetByID.mock
}

// Set uses given function f to mock the Users.GetByID method
func (mmGetByID *mUsersMockGetByID) Set(f func(ctx context.Context, userID int64) (up1 *model.User, err error)) *UsersMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the Users.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the Users.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	return mmGetByID.mock
}

// When sets expectation for the Users.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mUsersMockGetByID) When(ctx context.Context, userID int64) *UsersMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("UsersMock.GetByID mock is already set by Set")
	}

	expectation := &UsersMockGetByIDExpectation{
		mock:   mmGetByID.mock,
		params: &UsersMockGetByIDParams{ctx, userID},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up Users.GetByID return parameters for the expectation previously defined by the When method
func (e *UsersMockGetByIDExpectation) Then(up1 *model.User, err error) *UsersMock {
	e.results = &UsersMockGetByIDResults{up1, err}
	return e.mock
}

// Times sets number of times Users.GetByID should be invoked
func (mmGetByID *mUsersMockGetByID) Times(n uint64) *mUsersMockGetByID {
	if n == 0 {
		mmGetByID.mock.t.Fatalf("Times of UsersMock.GetByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByID.expectedInvocations, n)
	return mmGetByID
}

func (mmGetByID *mUsersMockGetByID) invocationsDone() bool {
	if len(mmGetByID.expectations) == 0 && mmGetByID.defaultExpectation == nil && mmGetByID.mock.funcGetByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByID.mock.afterGetByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByID implements repository.Users
func (mmGetByID *UsersMock) GetByID(ctx context.Context, userID int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, userID)
	}

	mm_params := UsersMockGetByIDParams{ctx, userID}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, &mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByID.GetByIDMock.defaultExpectation.paramPtrs

		mm_got := UsersMockGetByIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByID.t.Errorf("UsersMock.GetByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetByID.t.Errorf("UsersMock.GetByID got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("UsersMock.GetByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the UsersMock.GetByID")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, userID)
	}
	mmGetByID.t.Fatalf("Unexpected call to UsersMock.GetByID. %v %v", ctx, userID)
	return
}

// GetByIDAfterCounter returns a count of finished UsersMock.GetByID invocations
func (mmGetByID *UsersMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of UsersMock.GetByID invocations
func (mmGetByID *UsersMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mUsersMockGetByID) Calls() []*UsersMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*UsersMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockGetByIDDone() bool {
	if m.GetByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIDMock.invocationsDone()
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *UsersMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.GetByID with params: %#v", *e.params)
		}
	}

	afterGetByIDCounter := mm_atomic.LoadUint64(&m.afterGetByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && afterGetByIDCounter < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.GetByID")
		} else {
			m.t.Errorf("Expected call to UsersMock.GetByID with params: %#v", *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && afterGetByIDCounter < 1 {
		m.t.Error("Expected call to UsersMock.GetByID")
	}

	if !m.GetByIDMock.invocationsDone() && afterGetByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.GetByID but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIDMock.expectedInvocations), afterGetByIDCounter)
	}
}

type mUsersMockUpdate struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockUpdateExpectation
	expectations       []*UsersMockUpdateExpectation

	callArgs []*UsersMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockUpdateExpectation specifies expectation struct of the Users.Update
type UsersMockUpdateExpectation struct {
	mock      *UsersMock
	params    *UsersMockUpdateParams
	paramPtrs *UsersMockUpdateParamPtrs
	results   *UsersMockUpdateResults
	Counter   uint64
}

// UsersMockUpdateParams contains parameters of the Users.Update
type UsersMockUpdateParams struct {
	ctx            context.Context
	updateUserInfo model.UpdateUserInfo
}

// UsersMockUpdateParamPtrs contains pointers to parameters of the Users.Update
type UsersMockUpdateParamPtrs struct {
	ctx            *context.Context
	updateUserInfo *model.UpdateUserInfo
}

// UsersMockUpdateResults contains results of the Users.Update
type UsersMockUpdateResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mUsersMockUpdate) Optional() *mUsersMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for Users.Update
func (mmUpdate *mUsersMockUpdate) Expect(ctx context.Context, updateUserInfo model.UpdateUserInfo) *mUsersMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UsersMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UsersMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("UsersMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &UsersMockUpdateParams{ctx, updateUserInfo}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for Users.Update
func (mmUpdate *mUsersMockUpdate) ExpectCtxParam1(ctx context.Context) *mUsersMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UsersMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UsersMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UsersMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UsersMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdate
}

// ExpectUpdateUserInfoParam2 sets up expected param updateUserInfo for Users.Update
func (mmUpdate *mUsersMockUpdate) ExpectUpdateUserInfoParam2(updateUserInfo model.UpdateUserInfo) *mUsersMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UsersMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UsersMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UsersMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UsersMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.updateUserInfo = &updateUserInfo

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Users.Update
func (mmUpdate *mUsersMockUpdate) Inspect(f func(ctx context.Context, updateUserInfo model.UpdateUserInfo)) *mUsersMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for UsersMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Users.Update
func (mmUpdate *mUsersMockUpdate) Return(i1 int64, err error) *UsersMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UsersMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UsersMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &UsersMockUpdateResults{i1, err}
	return mmUpdate.mock
}

// Set uses given function f to mock the Users.Update method
func (mmUpdate *mUsersMockUpdate) Set(f func(ctx context.Context, updateUserInfo model.UpdateUserInfo) (i1 int64, err error)) *UsersMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Users.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Users.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the Users.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mUsersMockUpdate) When(ctx context.Context, updateUserInfo model.UpdateUserInfo) *UsersMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UsersMock.Update mock is already set by Set")
	}

	expectation := &UsersMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &UsersMockUpdateParams{ctx, updateUserInfo},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Users.Update return parameters for the expectation previously defined by the When method
func (e *UsersMockUpdateExpectation) Then(i1 int64, err error) *UsersMock {
	e.results = &UsersMockUpdateResults{i1, err}
	return e.mock
}

// Times sets number of times Users.Update should be invoked
func (mmUpdate *mUsersMockUpdate) Times(n uint64) *mUsersMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of UsersMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	return mmUpdate
}

func (mmUpdate *mUsersMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements repository.Users
func (mmUpdate *UsersMock) Update(ctx context.Context, updateUserInfo model.UpdateUserInfo) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, updateUserInfo)
	}

	mm_params := UsersMockUpdateParams{ctx, updateUserInfo}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := UsersMockUpdateParams{ctx, updateUserInfo}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("UsersMock.Update got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.updateUserInfo != nil && !minimock.Equal(*mm_want_ptrs.updateUserInfo, mm_got.updateUserInfo) {
				mmUpdate.t.Errorf("UsersMock.Update got unexpected parameter updateUserInfo, want: %#v, got: %#v%s\n", *mm_want_ptrs.updateUserInfo, mm_got.updateUserInfo, minimock.Diff(*mm_want_ptrs.updateUserInfo, mm_got.updateUserInfo))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("UsersMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the UsersMock.Update")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, updateUserInfo)
	}
	mmUpdate.t.Fatalf("Unexpected call to UsersMock.Update. %v %v", ctx, updateUserInfo)
	return
}

// UpdateAfterCounter returns a count of finished UsersMock.Update invocations
func (mmUpdate *UsersMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of UsersMock.Update invocations
func (mmUpdate *UsersMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mUsersMockUpdate) Calls() []*UsersMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*UsersMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *UsersMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.Update with params: %#v", *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.Update")
		} else {
			m.t.Errorf("Expected call to UsersMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Error("Expected call to UsersMock.Update")
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.Update but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UsersMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetByIDInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UsersMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UsersMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetByIDDone() &&
		m.MinimockUpdateDone()
}
